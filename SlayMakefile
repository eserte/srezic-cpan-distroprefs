{
    use File::chmod qw(symchmod);
    use CPAN::Kwalify;
    use Data::Dumper;
    BEGIN {
        if (!eval q{
            use YAML::Syck qw(LoadFile);
            1;
        }) {
            warn "Cannot load YAML::Syck, fallback to YAML...\n";
            require YAML;
            YAML->import(qw(LoadFile));
        }
    }
    use Kwalify qw(validate);
    use Safe;

    our $DISTROPREFS_SCHEMA;

    sub load_distroprefs_schema {
        return $DISTROPREFS_SCHEMA if $DISTROPREFS_SCHEMA;

        my $distroprefs_path = $INC{"CPAN/Kwalify.pm"};
	$distroprefs_path =~ s{\.pm$}{/distroprefs.dd};
	my $cpt = Safe->new;
	our $VAR1;
	$cpt->share('$VAR1');
	$cpt->rdo($distroprefs_path);
	my $schema = $VAR1;
	die "Cannot load schema from $distroprefs_path" if !$schema;

        $DISTROPREFS_SCHEMA = $schema;
    }

    sub validate_distroprefs {
        my($yml) = @_;
	my $schema = load_distroprefs_schema();
	my @errors;
	my(@data) = eval { LoadFile($yml) };
	if (!@data) {
	    push @errors, "Errors while loading $yml: $@";
	} else {
	    my $doc_i = -1;
	    for my $data (@data) {
		$doc_i++;
		push @errors, $@ if (!eval { validate($schema, $data) });
	    }
	    if (eval { require YAML; 1 }) {
		if (!eval { YAML::LoadFile($yml) }) {
		    push @errors, "Errors while loading $yml (doc#$doc_i) with YAML.pm: $@";
		}
	    }
	    ## XXX not yet enabled, most .yml files are not ready yet...
	    #if (eval { require YAML::XS; 1 }) {
	    #	if (!eval { YAML::XS::LoadFile($yml) }) {
	    #	    push @errors, "Errors while loading $yml (doc#$doc_i) with YAML::XS: $@";
	    #	}
	    #}
	}
	@errors;
    }
}

all:	do-stuff

do-stuff: validate dd-prefs permissions remove-outdated-dd

update:	git-pull
	{ system $0, "do-stuff" }

# alias for update
pull:	update

git-pull:
	git pull --rebase

push:	do-stuff git-push

git-push:
	git push

dd-prefs: { map { s{\.yml$}{.dd}; $_ } glob("*.yml") }

%.dd: %.yml
	{
		my($self, $target) = @_;
		(my $base = $target) =~ s{\.dd$}{};
		my $file = $base . ".yml";
	       	print STDERR "Creating .dd for $base...\n";
		my @y = LoadFile($file);
		open my $ofh, ">", "$target~" or die $!;
		print $ofh Data::Dumper->new(\@y)->Indent(1)->Useqq(1)->Purity(1)->Sortkeys(1)->Dump or die $!;
		close $ofh or die $!;
		rename "$target~", $target or die $!;
		"";
	}

permissions:
	{
		$File::chmod::UMASK = 0;
		symchmod "ugo+r", glob("*.yml"), glob("*.dd");
		"";
	}

validate: { map { ".validated/$_" } glob("*.yml") }

.validated/%.yml: %.yml
	{
	    my($self, $target) = @_;
	    (my $source = $target) =~ s{^\.validated/}{};
	    print STDERR "Validate $source...\n";
	    my @errors = validate_distroprefs($source);
	    if (@errors) {
		die "Found validation errors ($source):\n" . join("\n", @errors);
	    }
	    if (0) {
		system 'touch', $target;
		$? == 0 or die "Could not touch $target";
	    } else {
		open my $ofh, ">", $target or die "Could not touch $target: $!";
		print $ofh "--- {}\n";
		close $ofh or die "Error while writing to $target: $!";
	    }
	    "";
	}

validate-all:
	{
		my @errors;
		for my $yml (glob("*.yml")) {
		    push @errors, validate_distroprefs($yml);
		}
		if (@errors) { die "Found errors:\n" . join("\n", @errors) }
		else { "Validation OK.\n" }
	}

remove-outdated-dd:
	{
	    my @candidates;
	    for my $dd (glob("*.dd")) {
		my($yml) = $dd =~ m{^(.*)\.dd$};
		$yml .= ".yml";
		if (!-e $yml) {
		    push @candidates, $dd;
		}
	    }
	    if (@candidates) {
		print STDERR "About to remove @candidates...\n";
		unlink @candidates;
	    }
	    "";
	}

# find_dangerous_cpan_distributions.pl can be found in:
#   git://github.com/eserte/cpan-testers-parallelsmoker.git
# subdirectory utils
dangerous-cpan-distributions:
	find_dangerous_cpan_distributions.pl -distropref > 02.dangerous_cpan_distributions.yml~
	chmod ugo+r 02.dangerous_cpan_distributions.yml~
	mv 02.dangerous_cpan_distributions.yml~ 02.dangerous_cpan_distributions.yml
