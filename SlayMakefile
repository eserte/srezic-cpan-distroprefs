{
    use File::chmod qw(symchmod);
    use CPAN::Kwalify;
    use Data::Dumper;
    BEGIN {
        if (!eval q{
            use YAML::Syck qw(LoadFile);
            1;
        }) {
            warn "Cannot load YAML::Syck, fallback to YAML...\n";
            require YAML;
            YAML->import(qw(LoadFile));
        }
    }
    use Kwalify qw(validate);
    use Safe;

    our $DISTROPREFS_SCHEMA;
    our $TEST_ALSO_YAML_XS;

    sub load_distroprefs_schema {
        return $DISTROPREFS_SCHEMA if $DISTROPREFS_SCHEMA;

        my $distroprefs_path = $INC{"CPAN/Kwalify.pm"};
	$distroprefs_path =~ s{\.pm$}{/distroprefs.dd};
	my $cpt = Safe->new;
	our $VAR1;
	$cpt->share('$VAR1');
	$cpt->rdo($distroprefs_path);
	my $schema = $VAR1;
	die "Cannot load schema from $distroprefs_path" if !$schema;

        $DISTROPREFS_SCHEMA = $schema;
    }

    sub validate_distroprefs {
        my($yml) = @_;
	my $schema = load_distroprefs_schema();
	my @errors;
	my(@data) = eval { LoadFile($yml) };
	if (!@data) {
	    push @errors, "Errors while loading $yml: $@";
	} else {
	    my $doc_i = -1;
	    for my $data (@data) {
		$doc_i++;
		push @errors, $@ if (!eval { validate($schema, $data) });
	    }
	    if (eval { require YAML; 1 }) {
		if (!eval { YAML::LoadFile($yml) }) {
		    push @errors, "Errors while loading $yml (doc#$doc_i) with YAML.pm: $@";
		}
	    }
	    if ($TEST_ALSO_YAML_XS) {
		# XXX most .yml files are not ready yet, so this is not run by default...
	    	if (eval { require YAML::XS; 1 }) {
		    if (!eval { YAML::XS::LoadFile($yml) }) {
			push @errors, "Errors while loading $yml (doc#$doc_i) with YAML::XS: $@";
		    }
		}
	    }
	}
	@errors;
    }
}

all:	do-stuff

do-stuff: validate dd-prefs permissions remove-outdated-dd remove-outdated-valid

update:	git-pull
	{
		system $0, "do-stuff";
		"";
	}

# alias for update
pull:	update

git-pull:
	git pull --rebase

push:	do-stuff git-push

git-push:
	git push

push-and-smoker-pull:	push smoker-pull

smoker-pull:
	fbsd-dsh -g moresmoker -c -M 'cd .cpan/prefs && PATH=$HOME/bin/sh:$PATH slaymake pull'

dd-prefs: { map { s{\.yml$}{.dd}; $_ } glob("*.yml") }

%.dd: %.yml
	{
		my($self, $target) = @_;
		(my $base = $target) =~ s{\.dd$}{};
		my $file = $base . ".yml";
	       	print STDERR "Creating .dd for $base...\n";
		my @y = LoadFile($file);
		if (open my $ofh, ">", "$target~") {
		    print $ofh Data::Dumper->new(\@y)->Indent(1)->Useqq(1)->Purity(1)->Sortkeys(1)->Dump or die $!;
		    close $ofh or die $!;
		    rename "$target~", $target or die $!;
		} else {
		    warn "WARN: Could not create $target~: $! (this is OK if YAML is available)\n";
		}
		"";
	}

permissions:
	{
		$File::chmod::UMASK = 0;
		symchmod "ugo+r", glob("*.yml"), glob("*.dd");
		"";
	}

validate: { map { ".validated/$_" } glob("*.yml") }

.validated/%.yml: %.yml
	{
	    my($self, $target) = @_;
	    (my $source = $target) =~ s{^\.validated/}{};
	    print STDERR "Validate $source...\n";
	    my @errors = validate_distroprefs($source);
	    if (@errors) {
		die "Found validation errors ($source):\n" . join("\n", @errors);
	    }
	    if (0) {
		system 'touch', $target;
		$? == 0 or die "Could not touch $target";
	    } else {
		if (open my $ofh, ">", $target) {
		    print $ofh "--- {}\n";
		    close $ofh or die "Error while writing to $target: $!";
		} else {
		    warn "WARN: Could not touch $target: $! (validation will be repeated every time)\n";
		}
	    }
	    "";
	}

validate-all:
	{
		my @errors;
		for my $yml (glob("*.yml")) {
		    push @errors, validate_distroprefs($yml);
		}
		if (@errors) { die "Found errors:\n" . join("\n", @errors) }
		else { "Validation OK.\n" }
	}

validate-all-yaml-xs:
	{
		my @error_files;
		for my $yml (glob("*.yml")) {
		    our $TEST_ALSO_YAML_XS = 1;
		    local $TEST_ALSO_YAML_XS = 1;
		    if (validate_distroprefs($yml)) {
			push @error_files, $yml;
		    }
		}
		if (@error_files) { die "Found errors on following files:\n" . join("\n", @error_files) . "\n" }
		else { "Validation OK.\n" }
	}

remove-outdated-dd:
	{
	    my @candidates;
	    for my $dd (glob("*.dd")) {
		my($yml) = $dd =~ m{^(.*)\.dd$};
		$yml .= ".yml";
		if (!-e $yml) {
		    push @candidates, $dd;
		}
	    }
	    if (@candidates) {
		print STDERR "About to remove @candidates...\n";
		unlink @candidates;
	    }
	    "";
	}

remove-outdated-valid:
	{
	    my @candidates;
	    for my $valid (glob(".validated/*.yml")) {
		my($yml) = $valid =~ m{^\.validated/(.*)\.yml$};
		$yml .= ".yml";
		if (!-e $yml) {
		    push @candidates, $valid;
		}
	    }
	    if (@candidates) {
		print STDERR "About to remove @candidates...\n";
		unlink @candidates;
	    }
	    "";
	}

# find_dangerous_cpan_distributions.pl can be found in:
#   git://github.com/eserte/cpan-testers-parallelsmoker.git
# subdirectory utils
dangerous-cpan-distributions:
	{ warn "Be patient, loading CPAN index first...\n" }
	perl -MCPAN -e 'CPAN::Index->reload'      
	find_dangerous_cpan_distributions.pl -distropref > 02.dangerous_cpan_distributions.yml~
	chmod ugo+r 02.dangerous_cpan_distributions.yml~
	mv 02.dangerous_cpan_distributions.yml~ 02.dangerous_cpan_distributions.yml

dangerous-cpan-distributions-and-push-and-smoker-pull: dangerous-cpan-distributions _dangerous-cpan-distributions-commit push smoker-pull

_dangerous-cpan-distributions-commit:
	{
	    system("git", "diff", "--exit-code", "02.dangerous_cpan_distributions.yml");
	    if ($? != 0) {
		print STDERR "Commit and push changes? (y/n) ";
		while() {
		    chomp(my $yn = <STDIN>);
		    if ($yn eq 'y') {
			last;
		    } elsif ($yn ne 'n') {
			print STDERR "Please answer y or n.\n";
		    } else {
			exit 1;
		    }
		}
		system("git", "commit", "-m", "dangerous dists update", "02.dangerous_cpan_distributions.yml");
		if ($? != 0) {
		    die "git commit failed";
		}
	    } else {
		die "No diffs, nothing to commit.\n";
	    }
	}
